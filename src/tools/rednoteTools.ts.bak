import { AuthManager } from '../auth/authManager';
import { Browser, Page } from 'playwright';
import { logger } from '../utils/logger';
import { GetNoteDetail, NoteDetail } from './noteDetail';

export interface Note {
  title: string;
  content: string;
  tags: string[];
  url: string;
  author: string;
  likes?: number;
  collects?: number;
  comments?: number;
}

export interface Comment {
  author: string;
  content: string;
  likes: number;
  time: string;
  replies?: Comment[];
}

interface ScrollState {
  previousTop: number;
  newTop: number;
  height: number;
  client: number;
  remaining: number;
  scrolled: boolean;
}

interface ScrollResult {
  reachedEnd: boolean;
  message: string;
  hasEndText: boolean;
  scrollState?: ScrollState;
  error?: string;
  debug?: { selectors: string[]; tested: boolean };
}

export class RedNoteTools {
  private authManager: AuthManager;
  private browser: Browser | null = null;
  private page: Page | null = null;

  constructor() {
    logger.info('Initializing RedNoteTools');
    this.authManager = new AuthManager();
  }

  async initialize(): Promise<void> {
    logger.info('Initializing browser and page');
    this.browser = await this.authManager.getBrowser();
    if (!this.browser) {
      throw new Error('Failed to initialize browser');
    }
    
    try {
      this.page = await this.browser.newPage();
      
      // Load cookies if available
      const cookies = await this.authManager.getCookies();
      if (cookies.length > 0) {
        logger.info(`Loading ${cookies.length} cookies`);
        await this.page.context().addCookies(cookies);
      }

      // Check login status
      logger.info('Checking login status');
      await this.page.goto('https://www.xiaohongshu.com');
      const isLoggedIn = await this.page.evaluate(() => {
        const sidebarUser = document.querySelector('.user.side-bar-component .channel');
        return sidebarUser?.textContent?.trim() === '我';
      });

      // If not logged in, perform login
      if (!isLoggedIn) {
        logger.error('Not logged in, please login first');
        throw new Error('Not logged in');
      }
      logger.info('Login status verified');
    } catch (error) {
      // 初始化过程中出错，确保清理资源
      await this.cleanup();
      throw error;
    }
  }

  async cleanup(): Promise<void> {
    logger.info('Cleaning up browser resources');
    try {
      if (this.page) {
        await this.page.close().catch(err => logger.error('Error closing page:', err));
        this.page = null;
      }
      
      if (this.browser) {
        await this.browser.close().catch(err => logger.error('Error closing browser:', err));
        this.browser = null;
      }
    } catch (error) {
      logger.error('Error during cleanup:', error);
    } finally {
      this.page = null;
      this.browser = null;
    }
  }

  extractRedBookUrl(shareText: string): string {
    // 匹配 http://xhslink.com/ 开头的链接
    const xhslinkRegex = /(https?:\/\/xhslink\.com\/[a-zA-Z0-9\/]+)/i;
    const xhslinkMatch = shareText.match(xhslinkRegex);

    if (xhslinkMatch && xhslinkMatch[1]) {
      return xhslinkMatch[1];
    }

    // 匹配 https://www.xiaohongshu.com/ 开头的链接
    const xiaohongshuRegex = /(https?:\/\/(?:www\.)?xiaohongshu\.com\/[^，\s]+)/i;
    const xiaohongshuMatch = shareText.match(xiaohongshuRegex);

    if (xiaohongshuMatch && xiaohongshuMatch[1]) {
      return xiaohongshuMatch[1];
    }

    return shareText;
  }

  async searchNotes(keywords: string, limit: number = 10): Promise<Note[]> {
    logger.info(`Searching notes with keywords: ${keywords}, limit: ${limit}`);
    try {
      await this.initialize();
      if (!this.page) throw new Error('Page not initialized');

      // Navigate to search page
      logger.info('Navigating to search page');
      await this.page.goto(`https://www.xiaohongshu.com/search_result?keyword=${encodeURIComponent(keywords)}`);

      // Wait for search results to load
      logger.info('Waiting for search results');
      await this.page.waitForSelector('.feeds-container', {
        timeout: 30000
      });

      // Get all note items
      let noteItems = await this.page.$$('.feeds-container .note-item');
      logger.info(`Found ${noteItems.length} note items`);
      const notes: Note[] = [];

      // Process each note
      for (let i = 0; i < Math.min(noteItems.length, limit); i++) {
        logger.info(`Processing note ${i + 1}/${Math.min(noteItems.length, limit)}`);
        try {
          // Click on the note cover to open detail
          await noteItems[i].$eval('a.cover.mask.ld', (el: HTMLElement) => el.click());

          // Wait for the note page to load
          logger.info('Waiting for note page to load');
          await this.page.waitForSelector('#noteContainer', {
            timeout: 30000
          });

          await this.randomDelay(0.5, 1.5);

          // Extract note content
          const note = await this.page.evaluate(() => {
            const article = document.querySelector('#noteContainer');
            if (!article) return null;

            // Get title
            const titleElement = article.querySelector('#detail-title');
            const title = titleElement?.textContent?.trim() || '';

            // Get content
            const contentElement = article.querySelector('#detail-desc .note-text');
            const content = contentElement?.textContent?.trim() || '';

            // Get author info
            const authorElement = article.querySelector('.author-wrapper .username');
            const author = authorElement?.textContent?.trim() || '';

            // Get interaction counts from engage-bar
            const engageBar = document.querySelector('.engage-bar-style');
            const likesElement = engageBar?.querySelector('.like-wrapper .count');
            const likes = parseInt(likesElement?.textContent?.replace(/[^\d]/g, '') || '0');

            const collectElement = engageBar?.querySelector('.collect-wrapper .count');
            const collects = parseInt(collectElement?.textContent?.replace(/[^\d]/g, '') || '0');

            const commentsElement = engageBar?.querySelector('.chat-wrapper .count');
            const comments = parseInt(commentsElement?.textContent?.replace(/[^\d]/g, '') || '0');

            // Get tags
            const tagElements = article.querySelectorAll('.tag-item');
            const tags = Array.from(tagElements).map(tag => tag.textContent?.trim() || '').filter(Boolean);

            return {
              title,
              content,
              tags,
              url: window.location.href,
              author,
              likes,
              collects,
              comments
            };
          });

          if (note) {
            logger.info(`Extracted note: ${note.title}`);
            notes.push(note as Note);
          }

          // Add random delay before closing
          await this.randomDelay(0.5, 1);

          // Close note by clicking the close button
          const closeButton = await this.page.$('.close-circle');
          if (closeButton) {
            logger.info('Closing note dialog');
            await closeButton.click();

            // Wait for note dialog to disappear
            await this.page.waitForSelector('#noteContainer', {
              state: 'detached',
              timeout: 30000
            });
          }
        } catch (error) {
          logger.error(`Error processing note ${i + 1}:`, error);
          const closeButton = await this.page.$('.close-circle');
          if (closeButton) {
            logger.info('Attempting to close note dialog after error');
            await closeButton.click();

            // Wait for note dialog to disappear
            await this.page.waitForSelector('#noteContainer', {
              state: 'detached',
              timeout: 30000
            });
          }
        } finally {
          // Add random delay before next note
          await this.randomDelay(0.5, 1.5);
        }
      }

      logger.info(`Successfully processed ${notes.length} notes`);
      return notes;
    } catch (error) {
      logger.error('Error searching notes:', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  async getNoteContent(url: string): Promise<NoteDetail> {
    logger.info(`Getting note content for URL: ${url}`);
    try {
      await this.initialize();
      if (!this.page) throw new Error('Page not initialized');

      const actualURL = this.extractRedBookUrl(url);
      await this.page.goto(actualURL);
      let note = await GetNoteDetail(this.page);
      note.url = url;
      logger.info(`Successfully extracted note: ${note.title}`);
      return note;
    } catch (error) {
      logger.error('Error getting note content:', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  async getNoteComments(url: string): Promise<Comment[]> {
    logger.debug(`Getting comments for URL: ${url}`);
    try {
      await this.initialize();
      if (!this.page) throw new Error('Page not initialized');

      const actualURL = this.extractRedBookUrl(url);
      logger.debug(`Navigating to URL: ${actualURL}`);
      await this.page.goto(actualURL);

      // 获取评论总数（只包含一级评论）
      const commentCount = await this.page.evaluate(() => {
        // 尝试多种选择器来获取评论总数
        const selectors = [
          '.chat-wrapper .count',
          '.comment-wrapper .count',
          '[class*="comment"] .count',
          '.comment-count',
          '.comment-total',
          '.total-comments',
          '.comment-header .count',
          '.comment-header .total'
        ];

        for (const selector of selectors) {
          const element = document.querySelector(selector);
          if (element) {
            const text = element.textContent || '';
            const count = parseInt(text.replace(/[^\d]/g, ''));
            if (!isNaN(count) && count > 0) {
              return count;
            }
          }
        }

        // 如果通过选择器没有找到，尝试从评论列表获取
        const commentItems = document.querySelectorAll('.comment-item, .comment-card, [class*="comment-item"]');
        return commentItems.length;
      });

      logger.debug(`Expected total comments: ${commentCount}`);

      if (commentCount === 0) {
        logger.debug('No comments found');
        return [];
      }

      // 点击评论按钮
      logger.debug('Clicking comment button');
      await this.page.click('.chat-wrapper, .comment-wrapper, [class*="comment"]');

      // 等待评论对话框出现
      logger.debug('Waiting for comments dialog');
      await this.page.waitForSelector('.comment-modal, .comments-popup, [role="dialog"], .comments-container');

      // 等待第一条评论加载
      await this.page.waitForSelector('.comment-item, .comment-card, [class*="comment-item"]');
      await this.page.waitForTimeout(2000); // 等待评论列表完全显示

      //调用滚动加载评论方法
      await this.scrollAndLoadAllComments(this.page);

      // 调用提取出来的滚动加载评论方法
      const allComments = await this.scrollAndCollectAllComments(this.page, commentCount);

      // 统计所有评论（一级+二级）总数，并在主循环体内判断是否 break
      const totalComments = allComments.reduce((sum, comment) => {
        return sum + 1 + (Array.isArray(comment.replies) ? comment.replies.length : 0);
      }, 0);

      logger.debug(`Final comments count: ${totalComments}/${commentCount}`);
      if (totalComments < commentCount) {
        logger.debug(`Warning: Only retrieved ${totalComments} comments out of ${commentCount}`);
      }

      return allComments;
    } catch (error) {
      logger.error('Error getting comments:', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  /**
   * 滚动并收集所有评论
   */
  private async scrollAndCollectAllComments(page: Page, commentCount: number): Promise<Comment[]> {
    let allComments: Comment[] = [];
    while (true) {
      // 获取当前可见的评论
      const currentComments = await page.evaluate(() => {
        // 新的提取逻辑：遍历所有 parent-comment
        function extractContentWithEmoji(contentNode: Node): string {
          if (!contentNode) return '';
          let result = '';
          contentNode.childNodes.forEach((node: Node) => {
            if (node.nodeType === Node.TEXT_NODE) {
              result += node.textContent;
            } else if (node.nodeType === Node.ELEMENT_NODE && (node as HTMLElement).tagName === 'IMG' && (node as HTMLElement).classList.contains('note-content-emoji')) {
              const src = (node as HTMLImageElement).getAttribute('src');
              result += src ? `[emoji:${src}]` : '[emoji]';
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              result += extractContentWithEmoji(node);
            }
          });
          return result.trim();
        }

        const parentBlocks = document.querySelectorAll('.parent-comment');

        return Array.from(parentBlocks)
          .map(block => {
            // 一级评论（主评论）
            const mainComment = block.querySelector('.comment-item:not(.comment-item-sub)');
            if (!mainComment) return null;
            const author = mainComment.querySelector('.user-name, .nickname, [class*="user-name"], [class*="nickname"], .author')?.textContent?.trim() || '';
            const contentElem = mainComment.querySelector('.content, .desc, .text, [class*="content"], .comment-text');
            let content = contentElem ? extractContentWithEmoji(contentElem) : '';
            // 新增：查找图片
            const pictureImgs = block.querySelectorAll('.comment-picture img');
            pictureImgs.forEach(img => {
              const src = img.getAttribute('src');
              if (src) content += `[image:${src}]`;
            });
            // 如果内容为空但有图片，返回特殊标记
            if (!content.trim() && pictureImgs.length > 0) {
              content = '[图片评论]';
            }
            const likesText = mainComment.querySelector('.like-count, .likes, [class*="like"], .digg-count')?.textContent?.trim() || '0';
            const timeText = mainComment.querySelector('.time, .date, [class*="time"], .create-time')?.textContent?.trim() || '';
            const likes = parseInt(likesText.replace(/[^\d]/g, '')) || 0;

            // 二级评论（子评论/回复）
            const replies: any[] = [];
            const replyItems = block.querySelectorAll('.comment-item-sub');
            replyItems.forEach(replyItem => {
              const replyAuthor = replyItem.querySelector('.user-name, .nickname, [class*="user-name"], [class*="nickname"], .author')?.textContent?.trim() || '';
              const replyContentElem = replyItem.querySelector('.content, .desc, .text, [class*="content"], .comment-text');
              let replyContent = replyContentElem ? extractContentWithEmoji(replyContentElem) : '';
              // 查找图片
              const replyPictureImgs = replyItem.querySelectorAll('.comment-picture img');
              replyPictureImgs.forEach(img => {
                const src = img.getAttribute('src');
                if (src) replyContent += `[image:${src}]`;
              });
              // 如果内容为空但有图片，返回特殊标记
              if (!replyContent.trim() && replyPictureImgs.length > 0) {
                replyContent = '[图片评论]';
              }
              const replyLikesText = replyItem.querySelector('.like-count, .likes, [class*="like"], .digg-count')?.textContent?.trim() || '0';
              const replyTimeText = replyItem.querySelector('.time, .date, [class*="time"], .create-time')?.textContent?.trim() || '';
              const replyLikes = parseInt(replyLikesText.replace(/[^\d]/g, '')) || 0;

              replies.push({
                author: replyAuthor,
                content: replyContent,
                likes: replyLikes,
                time: replyTimeText
              });
            });

            return {
              author,
              content,
              likes,
              time: timeText,
              replies
            };
          })
          .filter(Boolean) as Comment[]; // 过滤掉null并明确类型
      });

      // 合并评论数组，避免重复
      for (const comment of currentComments) {
        // 检查是否已存在相同评论
        const existingIndex = allComments.findIndex(
          c => c.author === comment.author && c.content === comment.content && c.time === comment.time
        );

        if (existingIndex === -1) {
          allComments.push(comment);
        } else {
          // 如果评论已存在但有新回复，合并回复
          if (comment.replies && comment.replies.length > 0) {
            // 确保目标评论有replies数组
            if (!allComments[existingIndex].replies) {
              allComments[existingIndex].replies = [];
            }

            // 合并新回复，避免重复
            for (const reply of comment.replies) {
              const existingReplyIndex = allComments[existingIndex].replies!.findIndex(
                r => r.author === reply.author && r.content === reply.content && r.time === reply.time
              );

              if (existingReplyIndex === -1) {
                allComments[existingIndex].replies!.push(reply);
              }
            }
          }
        }
      }

      // 检查是否已获取足够的评论或到达页面底部
      if (allComments.length >= commentCount) {
        break;
      }

      // 先展开所有评论回复
      await this.expandAllCommentReplies(page);

      // 滚动加载更多评论
      const scrolled = await this.scrollAndLoadMoreComments(page);

      // 如果未能滚动（已到底部），则退出循环
      if (!scrolled) {
        break;
      }

      // 防止无限循环
      if (allComments.length > commentCount * 2) {
        logger.debug('Retrieved more comments than expected, stopping');
        break;
      }
    }

    return allComments;
  }

  /**
   * 展开所有评论回复
   */
  private async expandAllCommentReplies(page: Page): Promise<void> {
    try {
      // 查找并点击所有"展开回复"按钮
      const expandButtons = await page.$$('.expand-reply-button, .view-more-reply, .reply-more, [class*="expand-reply"], [class*="view-more-reply"], [class*="view-replies"]');
      
      for (const button of expandButtons) {
        try {
          // 检查按钮是否在视口内，如果不在则滚动到按钮位置
          const isInViewport = await button.isVisible();
          if (!isInViewport) {
            await button.scrollIntoViewIfNeeded();
            await page.waitForTimeout(500); // 等待滚动完成
          }
          
          // 点击展开回复按钮
          await button.click();
          await page.waitForTimeout(500); // 等待展开动画完成
        } catch (error) {
          // 忽略单个按钮的点击错误，继续处理下一个
          logger.debug('Error clicking expand reply button:', error);
        }
      }
      
      logger.debug(`Expanded ${expandButtons.length} reply sections`);
    } catch (error) {
      logger.error('Error expanding comment replies:', error);
    }
  }

  /**
   * 滚动加载更多评论
   */
  private async scrollAndLoadMoreComments(page: Page): Promise<boolean> {
    try {
      // 查找可滚动容器和底部加载指示器
      const scrollResult = await page.evaluate(() => {
        const selectors = [
          '.comment-list',
          '.comments-list',
          '[class*="comment-list"]',
          '.comment-panel',
          '.comments-panel',
          '[class*="comment-panel"]',
          '.comment-content',
          '.comments-content',
          '[class*="comment-content"]',
          '.scroll-container',
          '.scroll-area',
          '[class*="scroll"]',
          '.comment-modal',
          '.comments-popup',
          '[role="dialog"]',
          '.comments-container'
        ];
        
        // 找到可滚动容器
        let scrollContainer = null;
        let debug = { selectors: [] as string[], tested: false };
        
        for (const selector of selectors) {
          const elements = document.querySelectorAll(selector);
          debug.selectors.push(`${selector}: ${elements.length}`);
          
          for (const element of elements) {
            const style = window.getComputedStyle(element);
            const overflow = style.overflow + style.overflowY;
            const height = element.scrollHeight;
            const clientHeight = element.clientHeight;
            
            if ((overflow.includes('scroll') || overflow.includes('auto')) && height > clientHeight) {
              scrollContainer = element;
              debug.tested = true;
              break;
            }
          }
          
          if (scrollContainer) break;
        }
        
        if (!scrollContainer) {
          return {
            reachedEnd: true,
            message: 'No scrollable container found',
            hasEndText: false,
            debug
          };
        }
        
        // 记录滚动前的位置
        const previousTop = scrollContainer.scrollTop;
        
        // 滚动到底部
        scrollContainer.scrollBy(0, 1000);
        
        // 记录滚动后的位置
        const newTop = scrollContainer.scrollTop;
        const height = scrollContainer.scrollHeight;
        const client = scrollContainer.clientHeight;
        const remaining = height - (newTop + client);
        
        // 检查是否到达底部
        const nearBottom = remaining < 50;
        const hasEndText = !!document.querySelector('.loading-end, .no-more, .end-text, [class*="loading-end"], [class*="no-more"]');
        
        // 检查是否真的滚动了
        const scrolled = newTop > previousTop;
        
        return {
          reachedEnd: nearBottom || hasEndText,
          message: hasEndText ? 'Reached loading end text' : (nearBottom ? 'Near bottom' : 'Scrolled to load more'),
          hasEndText,
          scrollState: {
            previousTop,
            newTop,
            height,
            client,
            remaining,
            scrolled
          }
        };
      });
      
      // 等待内容加载
      await page.waitForTimeout(1500);
      
      logger.debug(`Scroll result: ${scrollResult.message}`, scrollResult);
      
      // 如果未能滚动或已到底部，返回false
      if (!scrollResult.reachedEnd && scrollResult.scrollState?.scrolled) {
        return true;
      }
      return false;
    } catch (error) {
      logger.error('Error scrolling for more comments:', error);
      return false;
    }
  }

  /**
   * 滚动加载所有评论
   */
  private async scrollAndLoadAllComments(page: Page): Promise<void> {
    logger.debug('Starting to scroll and load all comments');
    
    let previousHeight = 0;
    let sameHeightCount = 0;
    const MAX_SAME_HEIGHT = 3; // 连续相同高度的最大次数，超过则认为到达底部
    
    try {
      while (true) {
        // 获取容器的当前滚动高度
        const scrollData = await page.evaluate(() => {
          const selectors = [
            '.comment-list',
            '.comments-list',
            '[class*="comment-list"]',
            '.comment-panel',
            '.comments-panel',
            '[class*="comment-panel"]',
            '.comment-content',
            '.comments-content',
            '[class*="comment-content"]',
            '.scroll-container',
            '.scroll-area',
            '[class*="scroll"]',
            '.comment-modal',
            '.comments-popup',
            '[role="dialog"]',
            '.comments-container'
          ];
          
          // 找到可滚动容器
          let scrollContainer = null;
          
          for (const selector of selectors) {
            const elements = document.querySelectorAll(selector);
            
            for (const element of elements) {
              const style = window.getComputedStyle(element);
              const overflow = style.overflow + style.overflowY;
              const height = element.scrollHeight;
              const clientHeight = element.clientHeight;
              
              if ((overflow.includes('scroll') || overflow.includes('auto')) && height > clientHeight) {
                scrollContainer = element;
                break;
              }
            }
            
            if (scrollContainer) break;
          }
          
          if (!scrollContainer) {
            return { height: 0, scrolled: false };
          }
          
          // 记录滚动前的高度
          const currentHeight = scrollContainer.scrollHeight;
          
          // 滚动到最底部
          scrollContainer.scrollTo(0, currentHeight);
          
          return { height: currentHeight, scrolled: true };
        });
        
        // 等待内容加载
        await page.waitForTimeout(2000);
        
        // 如果没有找到滚动容器
        if (!scrollData.scrolled) {
          logger.debug('No scrollable container found, stopping scroll');
          break;
        }
        
        // 检查滚动高度是否变化
        if (scrollData.height === previousHeight) {
          sameHeightCount++;
          if (sameHeightCount >= MAX_SAME_HEIGHT) {
            logger.debug(`Scroll height unchanged for ${MAX_SAME_HEIGHT} times, stopping scroll`);
            break;
          }
        } else {
          sameHeightCount = 0; // 重置计数器
        }
        
        // 更新之前的高度
        previousHeight = scrollData.height;
        
        // 展开所有评论回复
        await this.expandAllCommentReplies(page);
      }
      
      logger.debug('Finished scrolling and loading all comments');
    } catch (error) {
      logger.error('Error in scrollAndLoadAllComments:', error);
    }
  }

  private async randomDelay(min: number, max: number): Promise<void> {
    const delay = Math.floor(Math.random() * (max - min + 1) + min) * 1000;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}